# training class for discriminator

#####TO DO#####
# 1 generator data loader
# 2 generator utility
# 3 combine generator and discriminator train

import math
import torch
import torch.nn as nn
import torch.optim as optim
import copy

import public as pb
from discriminator import Discriminator
from data_loader import MyDataLoader


class DiscriminatorUtility:
    def __init__(self):
        self.model = Discriminator(pb.dis_embed_dim, pb.vocab_size, pb.dis_filter_sizes, pb.dis_num_filters,
                                   pb.padding_idx, pb.dis_dropout, pb.dis_init_dist, pb.gpu)
        if pb.gpu:
            self.model.cuda()
        self.best_model = copy.deepcopy(self.model)
        # Criterion
        self.criterion = nn.BCEWithLogitsLoss()
        # Optimizer
        self.optimizer = optim.Adam(self.model.parameters(), lr=pb.dis_lr)

        self.train_losses = []
        self.test_losses = []

    # for general cnn classifier training
    def run(self, train_data_loader, test_data_loader, max_num_epoch=500):
        min_loss = math.inf
        train_losses = []
        test_losses = []
        epoch = 0
        for t in range(max_num_epoch):
            epoch += 1
            train_loss, train_accuracy = self.train(train_data_loader)
            test_loss,  test_accuracy  = self.evaluate(train_data_loader)
            train_losses.append(train_loss)
            test_losses.append(test_loss)

            if epoch > 10 and max_num_epoch-1 > 10:
                if test_loss < min_loss:
                    min_loss = test_loss
                    self.best_model = copy.deepcopy(self.model)
                if test_loss - test_losses[t-10] < 1e-3:
                    self.train_losses = train_losses
                    self.test_losses = test_losses
                    return self.best_model

    # for GAN discriminator training
    # def run(self, pos_data_loader, update_steps, update_epochs):
        # for t in range(update_steps):
            # positives = pos_data_loader
            # negatives = self.Generator.sample()  # samples generated by Generator
            # current_data = MyDataLoader(positives, negatives)

            # for e in range(update_epochs):
                # train_loss, train_accuracy = self.train(current_data)

    def train(self, train_data_loader):
        '''
        train network for one epoch
        :param train_data_loader: torch.utils.data.DataLoader for training
        :return: training loss, training accuracy
        '''
        self.model.train()
        loss, accuracy = 0, 0
        batches_num = len(train_data_loader)
        samples_num = 0
        for i, data in enumerate(train_data_loader):
            x, y = data['input'], data['label']
            if pb.gpu:
                x, y = x.cuda(), y.cuda()

            pred = self.model.forward(x)
            loss = self.criterion(pred, y)
            self.optimizer.zero_grad()
            loss.backward()
            torch.nn.utils.clip_grad_norm_(self.model.parameters(), max_norm=pb.max_norm)
            self.optimizer.step()

            loss += loss.item()
            accuracy += torch.sum(torch.tensor(pred.argmax(dim=-1) == y)).item()
            samples_num += x.size(0)

        loss /= batches_num
        accuracy /= samples_num
        return loss, accuracy

    def evaluate(self, test_data_loader):
        '''
        evaluate the current trained network
        :param test_data_loader: torch.utils.data.DataLoader for testing/validating
        :return: test loss, test accuracy
        '''
        self.model.eval()
        loss, accuracy = 0, 0
        batches_num = len(test_data_loader)
        samples_num = 0
        for i, data in enumerate(test_data_loader):
            x, y = data['input'], data['label']
            if pb.gpu:
                x, y = x.cuda(), y.cuda()

            pred = self.model.forward(x)
            loss = self.criterion(pred, y)

            loss += loss.item()
            accuracy += torch.sum(torch.tensor(pred.argmax(dim=-1) == y)).item()
            samples_num += x.size(0)

        loss /= batches_num
        accuracy /= samples_num
        return loss, accuracy

    def predict(self, input_sentence):
        return [1 if y>=0 else 0 for y in self.model(input_sentence)]
